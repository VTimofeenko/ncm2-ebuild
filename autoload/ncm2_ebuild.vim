" note: this file is autogenerated by jinja
if get(s:, 'loaded', 0)
    finish
endif
let s:loaded = 1

let g:ncm2_ebuild#proc = yarp#py3('ncm2_ebuild')
let g:ncm2_ebuild#proc.on_load = 'ncm2_ebuild#on_load'
" The list of classes to be included in completion
let g:ncm2_ebuild#eclass_list = ['desktop']

func! ncm2_ebuild#on_warmup(ctx) abort
	call g:ncm2_ebuild#proc.jobstart()
endfunc
func! ncm2_ebuild#init() abort
	call ncm2#register_source(g:ncm2_ebuild#phase_functions)
	call ncm2#register_source(g:ncm2_ebuild#variables)
endfunc


" Start phase_functions completion
" # character doesn't work well with abbreviation match
let g:ncm2_ebuild#phase_functions = extend(
			\ get(g:, 'ncm2_ebuild#phase_functions', {}), {
			\ 'name': 'ebuild_phase_functions',
			\ 'scope': ['ebuild'],
			\ 'priority': 0,
			\ 'mark': 'ep',
			\ 'on_complete': 'ncm2_ebuild#on_complete_phase_functions',
			\ 'complete_length': 1,
			\ 'word_pattern': '^[a-z]',
			\ }, 'keep')
			"\ 'word_pattern': ':[\w+-]*:?',

func! ncm2_ebuild#on_complete_phase_functions(ctx) abort
	let matches = [
                \ {'word': 'pkg_pretend(){ }', 'menu': 'run sanity checks for a package during dependency calculation time'},
                \ {'word': 'pkg_nofetch(){ }', 'menu': 'Tell the user how to deal with fetch-restricted packages'},
                \ {'word': 'pkg_setup(){ }', 'menu': 'Pre-build environment configuration and checks'},
                \ {'word': 'src_unpack(){ }', 'menu': 'Extract source packages.'},
                \ {'word': 'src_prepare(){ }', 'menu': 'Prepare source packages and do any necessary patching or fixes.'},
                \ {'word': 'src_configure(){ }', 'menu': 'Configure the package.'},
                \ {'word': 'src_compile(){ }', 'menu': 'Build the package.'},
                \ {'word': 'src_test(){ }', 'menu': 'Run pre-install test scripts'},
                \ {'word': 'src_install(){ }', 'menu': 'Install a package to ${D}'},
                \ {'word': 'pkg_preinst(){ }', 'menu': 'Called before image is installed to ${ROOT}'},
                \ {'word': 'pkg_postinst(){ }', 'menu': 'Called after image is installed to ${ROOT}'},
                \ {'word': 'pkg_prerm(){ }', 'menu': 'Called before a package is unmerged'},
                \ {'word': 'pkg_postrm(){ }', 'menu': 'Called after a package is unmerged'},
                \ {'word': 'pkg_config(){ }', 'menu': 'Run any special post-install configuration'},
                \ {'word': 'pkg_info(){ }', 'menu': 'display information about a package'},
				\ ]
	call ncm2#complete(a:ctx, a:ctx.startccol, matches)
endfunc
" End phase_functions completion

" Start variables completion
" # character doesn't work well with abbreviation match
let g:ncm2_ebuild#variables = extend(
			\ get(g:, 'ncm2_ebuild#variables', {}), {
			\ 'name': 'ebuild_variables',
			\ 'scope': ['ebuild'],
			\ 'priority': 0,
			\ 'mark': 'ep',
			\ 'on_complete': 'ncm2_ebuild#on_complete_variables',
			\ 'complete_length': 1,
			\ }, 'keep')
			"\ 'word_pattern': ':[\w+-]*:?',

func! ncm2_ebuild#on_complete_variables(ctx) abort
	let matches = [
                \ {'word': 'P', 'menu': 'Package name and version (excluding revision, if any), for example vim-6.3.'},
                \ {'word': 'PN', 'menu': 'Package name, for example vim.'},
                \ {'word': 'PV', 'menu': 'Package version (excluding revision, if any), for example 6.3. It should reflect the upstream versioning scheme.'},
                \ {'word': 'PR', 'menu': 'Package revision, or r0 if no revision exists.'},
                \ {'word': 'PVR', 'menu': 'Package version and revision (if any), for example 6.3, 6.3-r1.'},
                \ {'word': 'PF', 'menu': 'Full package name, ${PN}-${PVR}, for example vim-6.3-r1.'},
                \ {'word': 'A', 'menu': 'All the source files for the package (excluding those which are not available because of USE flags).'},
                \ {'word': 'CATEGORY', 'menu': 'Package''s category, for example app-editors.'},
                \ {'word': 'FILESDIR', 'menu': 'Path to the ebuild''s files/ directory, commonly used for small patches and files. For example: "${PORTDIR}/${CATEGORY}/${PN}/files".'},
                \ {'word': 'WORKDIR', 'menu': 'Path to the ebuild''s root build directory. For example: "${PORTAGE_BUILDDIR}/work".'},
                \ {'word': 'T', 'menu': 'Path to a temporary directory which may be used by the ebuild. For example: "${PORTAGE_BUILDDIR}/temp".'},
                \ {'word': 'D', 'menu': 'Path to the temporary install directory. For example: "${PORTAGE_BUILDDIR}/image".'},
                \ {'word': 'HOME', 'menu': 'Path to a temporary directory for use by any programs invoked by an ebuild that may read or modify the home directory. For example: "${PORTAGE_BUILDDIR}/homedir".'},
                \ {'word': 'ROOT', 'menu': 'The absolute path to the root directory into which the package is to be merged. Only allowed in pkg_* phases. See'},
                \ {'word': 'DISTDIR', 'menu': 'Contains the path to the directory where all the files fetched for the package are stored.'},
                \ {'word': 'EPREFIX', 'menu': 'The normalised offset-prefix path of an offset installation. See Gentoo Prefix Technical Documentation for more information.'},
                \ {'word': 'ED', 'menu': 'Shorthand for ${D%/}${EPREFIX}/.'},
                \ {'word': 'EROOT', 'menu': 'Shorthand for ${ROOT%/}${EPREFIX}/.'},
                \ {'word': 'SYSROOT', 'menu': '(EAPI=7) The absolute path to the root directory containing build dependencies satisfied by DEPEND'},
                \ {'word': 'ESYSROOT', 'menu': '(EAPI=7) Shorthand for ${SYSROOT%/}${EPREFIX}/.'},
                \ {'word': 'BROOT', 'menu': '(EAPI=7) The absolute path to the root directory containing build dependencies satisfied by BDEPEND, typically executable build tools.'},
                \ {'word': 'MERGE_TYPE', 'menu': 'The type of package that is being merged. Possible values are: source if building and installing a package from source, binary if installing a binary package previously built from the ebuild, buildonly if building a binary package without installing it.'},
                \ {'word': 'REPLACING_VERSIONS', 'menu': 'A whitespace-separated list of all versions (PVR) of this package that are being replaced (uninstalled or overwritten) as a result of this install. It is a list, not a single optional value, to handle pathological cases such as installing foo-2:2 to replace foo-2:1 and foo-3:2. Available in pkg_preinst and pkg_postinst.'},
                \ {'word': 'REPLACED_BY_VERSION', 'menu': 'The single version (PVR) of this package that is replacing the version provided by this ebuild, if it is being uninstalled as part of an install. An empty string otherwise, i.e., if it is being uninstalled without replacement. Available in pkg_prerm and pkg_postrm.'},
                \ {'word': 'EAPI', 'menu': 'The EAPI. See .'},
                \ {'word': 'DESCRIPTION', 'menu': 'A short (not more than 80 characters) description of the package''s purpose. Mandatory.'},
                \ {'word': 'HOMEPAGE', 'menu': 'Package''s homepage(s). Mandatory (except for virtuals), accepts multiple values. In some contexts, it is customary to provide package tracker and/or code hosting links besides the main homepage (e.g. PyPI link for Python packages, GitHub link when code can''t easily be found on homepage) for convenience. If no homepage for the package is available, please set it to https://wiki.gentoo.org/wiki/No_homepage. Never refer to a variable name in the string; include only raw text.'},
                \ {'word': 'SRC_URI', 'menu': 'A list of source URIs for the package. Can contain USE-conditional parts, see .'},
                \ {'word': 'LICENSE', 'menu': 'The package''s license, corresponding exactly (including case) to a file in licenses/. Mandatory (except for virtuals). See .'},
                \ {'word': 'SLOT', 'menu': 'The package''s SLOT. Mandatory. See .'},
                \ {'word': 'KEYWORDS', 'menu': 'See and .'},
                \ {'word': 'IUSE', 'menu': 'A list of all USE flags (excluding arch flags, but including USE_EXPAND flags) used within the ebuild. See .'},
                \ {'word': 'REQUIRED_USE', 'menu': 'A list of assertions that must be met by the configuration of USE flags to be valid for this ebuild. See .'},
                \ {'word': 'PROPERTIES', 'menu': 'A space-delimited list of properties, with conditional syntax support. interactive is the only valid value for now.'},
                \ {'word': 'RESTRICT', 'menu': 'A space-delimited list of portage features to restrict. Valid values are fetch, mirror, strip, test and userpriv. See man 5 ebuild for details.'},
                \ {'word': 'DEPEND', 'menu': 'A list of the package''s build dependencies'},
                \ {'word': 'BDEPEND', 'menu': '(EAPI=7) A list of the package''s CBUILD build dependencies'},
                \ {'word': 'RDEPEND', 'menu': 'A list of the package''s runtime dependencies.'},
                \ {'word': 'PDEPEND', 'menu': 'A list of packages to be installed (if possible) after the package is merged. Use this only when RDEPEND would cause cyclic dependencies.'},
                \ {'word': 'S', 'menu': 'Path to the temporary build directory, used by src_compile and src_install. Default: "${WORKDIR}/${P}". Ebuilds should not provide a value for this variable if it is the same as the default value.'},
                \ {'word': 'DOCS', 'menu': 'An array or whitespace-separated list of documentation files for the default src_install function to install using dodoc. If undefined, a reasonable default list is used. See the default src_install function.'},
                \ {'word': 'HTML_DOCS', 'menu': 'An array or space-delimited list of documentation files or directories for the einstalldocs function to install recursively. (Requires EAPI>=6.)'},
                \ {'word': 'ver_rs', 'menu': 'Get important version components, excluding ''.'', ''-'' and ''_''.'},
                \ {'word': 'ver_cut', 'menu': 'Get the major version.'},
                \ {'word': 'ver_cut', 'menu': 'Extract a range of subparts from a version string.'},
                \ {'word': 'ver_cut', 'menu': 'Get everything after the major version.'},
                \ {'word': 'ver_rs', 'menu': 'Replace a particular version separator.'},
                \ {'word': 'ver_rs', 'menu': 'Replace all version separators.'},
                \ {'word': 'ver_rs', 'menu': 'Delete a version separator.'},
                \ {'word': 'ver_rs', 'menu': 'Delete all version separators.'},
				\ ]
	call ncm2#complete(a:ctx, a:ctx.startccol, matches)
endfunc
" End variables completion

" Generated on 2021-02-28